# Development workflow with migrations

- Write your SQL migration code into the `./migrations/current.sql` file.
- Start the backend service
  - When the app is in DEV mode (NODE_ENV=development) graphile-migrate `watch`
    command is executed. This applies all unapplied committed migrations from
    `./migrations/committed` folder. In addition it **watches** the
    `current.sql` file for any changes. If there is a change it executes the
    `current.sql` file immediately against the database. By default this will
    re-generate the PostGraphile schema and seamlessly update any open GraphiQL
    browser window.
  - When not in DEV mode (NODE_ENV is anything other than development), the
    graphile-migrate `migrate` command is executed. This applies all unapplied
    committed migrations from `./migrations/committed` folder but not the
    `current.sql` file contents.
- Make adjustments to `current.sql` while app is running or is stopped, test the
  migration SQL.
  - It is **highly** advised to write idempotent SQL migrations.
  - See this for more https://github.com/graphile/migrate#idempotency
- When you are happy with the migration code (ideally just before merging it to
  the master branch) run `yarn run db:commit` command to commit your
  `current.sql` migration code.
- If you have committed your migration, but feel like you should make more
  adjustments to it - run `yarn run db:uncommit` to undo the commit and move
  previously committed SQL migration back to the `current.sql` file.
- If you feel like your migration experimentation irreversibly corrupted your
  database (or you just want a fresh start) - run `yarn run db:reset`

# Notes on Merging

Let's say that two developers are working in two different feature branches.
Both have some changes in `current.sql`, and developer 1 merges his code into
master:

- Developer 1 runs `db:commit` to commit the SQL migration. This has to be done
  before the GIT merge. This way the `current.sql` file in master will always
  stay empty.
- Developer 2 can safely GIT merge the changes from master into his current
  branch without a need to resolve GIT merge conflicts in the SQL migration
  files. If Developer 2 already committed his `current.sql` changes, he/she has
  to run `yarn run db:uncommit` to move the changes back to `current.sql`
- After the merge, Developer 2 needs to make sure that his migration SQL (in
  `current.sql`) is compatible with the newly committed migration which
  Developer 1 introduced. Potentially this requires some adjustments.

  # Example migration

```sql
--! Message: your-migration-name

-- Put your migration statements/code below this line.
-- Don't forget to write them in an idempotent manner.
------------------------------------------------------

DROP TABLE IF EXISTS your_table_name CASCADE;
CREATE TABLE your_table_name (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name TEXT NOT NULL,
  created_at DATE NOT NULL DEFAULT NOW(),
  description TEXT
);
```
