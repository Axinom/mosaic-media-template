--! Previous: sha1:07dccfe45a45745a68b910d30594774debf23731
--! Hash: sha1:46d824117e4201a61a7eb6d51245acd74f381e38
--! Message: added snapshots

-- #snapshots
DROP TYPE IF EXISTS app_public.snapshot_state CASCADE;
CREATE TYPE app_public.snapshot_state AS enum (
  'INITIALIZATION',
  'VALIDATION',
  'INVALID',
  'READY',
  'SCHEDULED',
  'PUBLISHED',
  'UNPUBLISHED',
  'VERSION_MISMATCH'
);
SELECT ax_define.expose_enum_endpoint('snapshot_state', 'app_public');

DROP TYPE IF EXISTS app_public.entity_type CASCADE;
CREATE TYPE app_public.entity_type AS ENUM (
  'MOVIE',
  'MOVIE_GENRE',
  'TVSHOW',
  'TVSHOW_GENRE',
  'SEASON',
  'EPISODE',
  'COLLECTION'
);
SELECT ax_define.expose_enum_endpoint('entity_type', 'app_public');

DROP TYPE IF EXISTS app_public.snapshot_validation_status CASCADE;
CREATE TYPE app_public.snapshot_validation_status AS enum (
  'OK',
  'WARNINGS',
  'ERRORS'
);
SELECT ax_define.expose_enum_endpoint('snapshot_validation_status', 'app_public');

DROP TABLE IF EXISTS snapshots CASCADE;
CREATE TABLE snapshots (
  id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  entity_id INT NOT NULL, -- denormalized content entity ID
  publish_id TEXT NOT NULL,
  job_id TEXT NOT NULL, -- auto generated, bulk created snapshots will have the same ID
  snapshot_no INT NOT NULL, -- auto generated, essentially just a sequence number for snapshots of the same entity
  entity_title TEXT, -- denormalized entity title at the time of publication
  entity_type entity_type NOT NULL,
  validation_status app_public.snapshot_validation_status,
  snapshot_json JSON,
  snapshot_state snapshot_state NOT NULL DEFAULT 'INITIALIZATION',
  scheduled_date TIMESTAMPTZ,
  published_date TIMESTAMPTZ,
  unpublished_date TIMESTAMPTZ,
  created_date TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_date TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  created_user TEXT NOT NULL DEFAULT ':DEFAULT_USERNAME',
  updated_user TEXT NOT NULL DEFAULT ':DEFAULT_USERNAME'
);
GRANT INSERT, UPDATE (
  entity_id,
  publish_id,
  job_id,
  snapshot_no,
  entity_title,
  entity_type,
  snapshot_state,
  validation_status,
  snapshot_json,
  scheduled_date,
  published_date,
  unpublished_date,
  created_date,
  updated_date,
  created_user,
  updated_user
) ON app_public.snapshots TO ":DATABASE_GQL_ROLE";
GRANT SELECT, DELETE ON app_public.snapshots TO ":DATABASE_GQL_ROLE";
SELECT ax_define.define_indexes_with_id('entity_id', 'snapshots', 'app_public');
SELECT ax_define.define_indexes_with_id('entity_type', 'snapshots', 'app_public');
SELECT ax_define.define_indexes_with_id('snapshot_state', 'snapshots', 'app_public');
SELECT ax_define.define_indexes_with_id('validation_status', 'snapshots', 'app_public');
SELECT ax_define.define_indexes_with_id('scheduled_date', 'snapshots', 'app_public');
SELECT ax_define.define_indexes_with_id('created_date', 'snapshots', 'app_public');
SELECT ax_define.define_indexes_with_id('published_date', 'snapshots', 'app_public');

-- #snapshot_validation
DROP TYPE IF EXISTS app_public.snapshot_validation_issue_context CASCADE;
CREATE TYPE app_public.snapshot_validation_issue_context AS enum (
  'METADATA',
  'LICENSING',
  'IMAGES',
  'VIDEO'
);
SELECT ax_define.expose_enum_endpoint('snapshot_validation_issue_context', 'app_public');

DROP TYPE IF EXISTS app_public.snapshot_validation_issue_severity CASCADE;
CREATE TYPE app_public.snapshot_validation_issue_severity AS ENUM (
  'WARNING',
  'ERROR'
);
SELECT ax_define.expose_enum_endpoint('snapshot_validation_issue_severity', 'app_public');

DROP TABLE IF EXISTS app_public.snapshot_validation_results CASCADE;
CREATE TABLE app_public.snapshot_validation_results (
  id INT NOT NULL PRIMARY KEY generated by DEFAULT AS IDENTITY,
  snapshot_id INT REFERENCES app_public.snapshots ON DELETE CASCADE,
  severity app_public.snapshot_validation_issue_severity NOT NULL,
  context app_public.snapshot_validation_issue_context NOT NULL,
  message TEXT NOT NULL
);
GRANT INSERT, UPDATE (
  snapshot_id,
  severity,
  context
) ON app_public.snapshot_validation_results TO ":DATABASE_GQL_ROLE";
GRANT SELECT, DELETE ON app_public.snapshot_validation_results TO ":DATABASE_GQL_ROLE";
SELECT ax_define.define_index('snapshot_id', 'snapshot_validation_results', 'app_public');
SELECT ax_define.define_index('severity', 'snapshot_validation_results', 'app_public');

-- #snapshot_xrefs

-- Trigger function to clean up orphaned snapshots after a content entity has been deleted.
CREATE OR REPLACE FUNCTION remove_orphaned_snapshot()
RETURNS TRIGGER
AS
$func$
BEGIN
	DELETE
	FROM
		snapshots
	WHERE
		id = OLD.snapshot_id;
	RETURN NULL;
END
$func$ LANGUAGE plpgsql;

-- #movies_snapshots
DROP TABLE IF EXISTS app_public.movies_snapshots CASCADE;
CREATE TABLE app_public.movies_snapshots (
  movie_id int REFERENCES app_public.movies ON DELETE CASCADE,
  snapshot_id int REFERENCES app_public.snapshots ON DELETE CASCADE,
  UNIQUE(movie_id, snapshot_id),
  PRIMARY KEY(movie_id, snapshot_id)
);
GRANT INSERT, UPDATE (movie_id, snapshot_id) ON app_public.movies_snapshots TO ":DATABASE_GQL_ROLE";
GRANT SELECT, DELETE ON app_public.movies_snapshots TO ":DATABASE_GQL_ROLE";

DROP TRIGGER IF EXISTS tg_cleanup_orphaned_movie_snapshots ON movies_snapshots;
CREATE TRIGGER tg_cleanup_orphaned_movie_snapshots
AFTER DELETE ON movies_snapshots
FOR EACH ROW EXECUTE PROCEDURE remove_orphaned_snapshot();

-- #movie_genres_snapshots
DROP TABLE IF EXISTS app_public.movie_genres_snapshots CASCADE;
CREATE TABLE app_public.movie_genres_snapshots (
  movie_genre_id int REFERENCES app_public.movie_genres ON DELETE CASCADE,
  snapshot_id int REFERENCES app_public.snapshots ON DELETE CASCADE,
  UNIQUE(movie_genre_id, snapshot_id),
  PRIMARY KEY(movie_genre_id, snapshot_id)
);
GRANT INSERT, UPDATE (movie_genre_id, snapshot_id) ON app_public.movie_genres_snapshots TO ":DATABASE_GQL_ROLE";
GRANT SELECT, DELETE ON app_public.movie_genres_snapshots TO ":DATABASE_GQL_ROLE";

DROP TRIGGER IF EXISTS tg_cleanup_orphaned_movie_genre_snapshots ON movie_genres_snapshots;
CREATE TRIGGER tg_cleanup_orphaned_movie_genre_snapshots
AFTER DELETE ON movie_genres_snapshots
FOR EACH ROW EXECUTE PROCEDURE remove_orphaned_snapshot();

-- #tvshows_snapshots
DROP TABLE IF EXISTS app_public.tvshows_snapshots CASCADE;
CREATE TABLE app_public.tvshows_snapshots (
  tvshow_id int REFERENCES app_public.tvshows ON DELETE CASCADE,
  snapshot_id int REFERENCES app_public.snapshots ON DELETE CASCADE,
  UNIQUE(tvshow_id, snapshot_id),
  PRIMARY KEY(tvshow_id, snapshot_id)
);
GRANT INSERT, UPDATE (tvshow_id, snapshot_id) ON app_public.tvshows_snapshots TO ":DATABASE_GQL_ROLE";
GRANT SELECT, DELETE ON app_public.tvshows_snapshots TO ":DATABASE_GQL_ROLE";

DROP TRIGGER IF EXISTS tg_cleanup_orphaned_tvshow_snapshots ON tvshows_snapshots;
CREATE TRIGGER tg_cleanup_orphaned_tvshow_snapshots
AFTER DELETE ON tvshows_snapshots
FOR EACH ROW EXECUTE PROCEDURE remove_orphaned_snapshot();

-- #tvshow_genres_snapshots
DROP TABLE IF EXISTS app_public.tvshow_genres_snapshots CASCADE;
CREATE TABLE app_public.tvshow_genres_snapshots (
  tvshow_genre_id int REFERENCES app_public.tvshow_genres ON DELETE CASCADE,
  snapshot_id int REFERENCES app_public.snapshots ON DELETE CASCADE,
  UNIQUE(tvshow_genre_id, snapshot_id),
  PRIMARY KEY(tvshow_genre_id, snapshot_id)
);
GRANT INSERT, UPDATE (tvshow_genre_id, snapshot_id) ON app_public.tvshow_genres_snapshots TO ":DATABASE_GQL_ROLE";
GRANT SELECT, DELETE ON app_public.tvshow_genres_snapshots TO ":DATABASE_GQL_ROLE";

DROP TRIGGER IF EXISTS tg_cleanup_orphaned_tvshow_genre_snapshots ON tvshow_genres_snapshots;
CREATE TRIGGER tg_cleanup_orphaned_tvshow_genre_snapshots
AFTER DELETE ON tvshow_genres_snapshots
FOR EACH ROW EXECUTE PROCEDURE remove_orphaned_snapshot();

-- #seasons_snapshots
DROP TABLE IF EXISTS app_public.seasons_snapshots CASCADE;
CREATE TABLE app_public.seasons_snapshots (
  season_id int REFERENCES app_public.seasons ON DELETE CASCADE,
  snapshot_id int REFERENCES app_public.snapshots ON DELETE CASCADE,
  UNIQUE(season_id, snapshot_id),
  PRIMARY KEY(season_id, snapshot_id)
);
GRANT INSERT, UPDATE (season_id, snapshot_id) ON app_public.seasons_snapshots TO ":DATABASE_GQL_ROLE";
GRANT SELECT, DELETE ON app_public.seasons_snapshots TO ":DATABASE_GQL_ROLE";

DROP TRIGGER IF EXISTS tg_cleanup_orphaned_season_snapshots ON seasons_snapshots;
CREATE TRIGGER tg_cleanup_orphaned_season_snapshots
AFTER DELETE ON seasons_snapshots
FOR EACH ROW EXECUTE PROCEDURE remove_orphaned_snapshot();

-- #episodes_snapshots
DROP TABLE IF EXISTS app_public.episodes_snapshots CASCADE;
CREATE TABLE app_public.episodes_snapshots (
  episode_id int REFERENCES app_public.episodes ON DELETE CASCADE,
  snapshot_id int REFERENCES app_public.snapshots ON DELETE CASCADE,
  UNIQUE(episode_id, snapshot_id),
  PRIMARY KEY(episode_id, snapshot_id)
);
GRANT INSERT, UPDATE (episode_id, snapshot_id) ON app_public.episodes_snapshots TO ":DATABASE_GQL_ROLE";
GRANT SELECT, DELETE ON app_public.episodes_snapshots TO ":DATABASE_GQL_ROLE";

DROP TRIGGER IF EXISTS tg_cleanup_orphaned_episode_snapshots ON episodes_snapshots;
CREATE TRIGGER tg_cleanup_orphaned_episode_snapshots
AFTER DELETE ON episodes_snapshots
FOR EACH ROW EXECUTE PROCEDURE remove_orphaned_snapshot();

-- #collections_snapshots
DROP TABLE IF EXISTS app_public.collections_snapshots CASCADE;
CREATE TABLE app_public.collections_snapshots (
  collection_id int REFERENCES app_public.collections ON DELETE CASCADE,
  snapshot_id int REFERENCES app_public.snapshots ON DELETE CASCADE,
  UNIQUE(collection_id, snapshot_id),
  PRIMARY KEY(collection_id, snapshot_id)
);
GRANT INSERT, UPDATE (collection_id, snapshot_id) ON app_public.collections_snapshots TO ":DATABASE_GQL_ROLE";
GRANT SELECT, DELETE ON app_public.collections_snapshots TO ":DATABASE_GQL_ROLE";

DROP TRIGGER IF EXISTS tg_cleanup_orphaned_collection_snapshots ON collections_snapshots;
CREATE TRIGGER tg_cleanup_orphaned_collection_snapshots
AFTER DELETE ON collections_snapshots
FOR EACH ROW EXECUTE PROCEDURE remove_orphaned_snapshot();
